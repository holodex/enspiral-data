#!/usr/bin/env node

var Path = require('path')
var fs = require('fs')
var levelup = require('levelup')
var levelws = require('level-ws')
var fsdown = require('fsdown')
var map = require('lodash.map')
var assign = require('lodash.assign')
var through = require('through2')
var multistream = require('multistream')
var forkable = require('forkable')

var migratePath = process.argv[2]
if (migratePath == null) {
  console.log("migrate path not given!")
  process.exit(1)
}

var migrate = require(
  Path.join(process.cwd(), migratePath)
)

if (typeof migrate !== 'function') {
  console.log("migrate is not a function")
  process.exit(1)
}

// get starting db inputs
var inputs = fs.readdirSync('.')
.filter(function (path) { return Path.extname(path) === '.csv'})
.map(function (path) {
  var type = Path.basename(path, '.csv')
  return getDb(type)
})
.map(function (db) {
  return db.createReadStream({ valueEncoding: 'json' })
  .pipe(through.obj(function (row, enc, cb) {
    assign(row.value, { type: db.type })
    cb(null, row)
  }))
})

// migrate
var migrated = multistream.obj(inputs).pipe(migrate())

migrated.on('data', console.log)

var outputs = {} 

// get ending db outputs
forkable(
  migrated
)
.fork(function (row) {
  var type = row.value.type
  delete row.value.type
  if (outputs[type] == null) {
    outputs[type] = getDb(type, true)
  }
  return type
})
.pipe(function (type) {
  return outputs[type].createWriteStream({ valueEncoding: 'json' })
})

function getDb (type, isTmp) {
  var dir = isTmp ? 'tmp' : ''
  var path = Path.join(process.cwd(), dir, type + '.csv')
  var db = levelws(levelup(path, {
    db: fsdown({ codec: 'csv', keyAttribute: 'id' })
  }))
  db.type = type
  return db
}
